# 深入研究下泛型、反射、代理
                
note:补一下基础，并深入研究一下，特别是泛型。参考书籍：《Java编程思想》，《Java核心技术卷一》

## 泛型

    note:泛型使用是一件简单的事情，而如何设计泛型类则是有点难度的。本节重点也在学习如何设计泛型类。

### 泛型：适用于许多许多的类型

 * 代码使用于"某种不确定的类型"，而不是具体的接口或类。
 * 类或方法具备广泛的适用性。

#### 参数化类型
```text
    note:这么理解参数化类型吧：普通的方法参数或类的构造方法可能包含若干参数，这些参数(形参)必定是一个固定类型，
    实参是这个类型的一个实例。但参数化类型作为方法参数或类参数的时候，它是"某种不确定的类型"，当然参数化类型定义
    的方式和普通方法和类有些差别的。简言之，就是可以定义这么一个类或方法，让它接受一个不知道是什么类型的参数
    (当然不会是Object类型这么简单的方式)。
```
#### 简单泛型

有许多原因促成了泛型的出现，而最引人注目的一个原因，就是为了创造<b>容器类</b>。 ---《Java编程思想》

    note:为了让容器灵活的持有各种类型,这是一个泛型出现的重要原因。
    
糟糕容器：
com.lingyun.generics.BadHolder
```java
public class BadHolder1 {
    private Automobile a;
    public BadHolder1(Automobile a){
        this.a=a;
    }

    public Automobile get() {
        return a;
    }
}
```
为什么它是一个糟糕的容器？作为一个容器，它应该容纳万物，它仅关心容器本身就好，比如是否能重复元素，是否排序，
如何取得元素等等。而这个容器只能容纳Automobile类型及Automobile扩展。

糟糕的解决方案：Automobile类型变为Object类型似乎可以解决容纳一切的问题，可以存放Automobile、String等等一切，
但它的糟糕之处在哪里呢？

com.lingyun.generics.BadHolder2

```java
public class BadHolder2 {
    private Object a;
    public BadHolder2(Object a){
        this.a=a;
    }

    public Object get() {
        return a;
    }
}

```
不难想像，当我们调用get方法时，我们获得的是一个Object，必定存在强制类型转换。一般说来我们实例化一个容器的时候，
是希望容器能持有某种具体类型的，比如我们希望容器是一个Automobile容器。
```text
note:这里需要区分一下泛型程序的设计者和使用者不同角色，从设计者的角度看，他希望泛型能容纳所有不确定的东西，
从使用者的角度看，则希望容器容纳他所希望的某种类型。
```
    
因此，与其使用Object，我们更喜欢暂时不指定类型，而是稍后再决定具体使用什么类型。要达到这个目的，需要使用类型参数，
用尖括号扩住，放在类名后面。然后在使用这个类的时候，再用实际的类型替换此类型参数。 ------《Java编程思想》    
